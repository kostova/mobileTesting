/**
 * Client
 * represents a client on the server. handles the websocket, handshake, maintaining the client
 * state, and forwarding and recieving messages for this client.
 */
var util = require("util"),
	events = require("events"),
	utils = require('./utils'),
	logger = require('./logger.js'),
	MessageStash = require('./MessageStash.js'),
	TsProtocol = require('./TsAutomationProtocol.js');

/**
 * Client constructor
 * @param {WebSocket} connection - the websocket for this Client to watch
 * @param {messageTimeout} timeout - the message timeout
 */
function Client(connection, messageTimeout) {
	this._messageTimeout = messageTimeout;
	this.messageStash = new MessageStash(messageTimeout);

	logger.debug("Client connecting...");

	if(!connection || !connection.on || !connection.sendUTF || !connection.close){
		throw "Missing or invalid websocket connection object";
	}

	// getter/setter for "private" vars
	this.getId = function(){
		return this._id;
	};
	this.setResumeId = function(resumeId){
		this._id = resumeId;
	};
	this.getStatus = function(){
		return this._status;
	};
	this._setStatus = function(status){
		var oldStatus = this._status;
		this._status = status;
		this.emit("statusChange", this, oldStatus);
	};
	this.getPlatformInfo = function() {
		return this._platformInfo;
	};
	this.getCapabilities = function() {
		return this._capabilities;
	};
	this.getIdentity = function() {
		return this._identity;
	};

	this._id = utils.uuid();
	this._connection = connection;
	this._platformInfo = undefined;
	this._capabilities = undefined;
	this._identity = undefined;
	this._setStatus(undefined);
	this._suspendTimer = undefined;

	// route incoming messages
	// NOTE: websocket connection events dont go through bindEvents
	this._connection.on('message', this._onMessage.bind(this));
	this._connection.on('close', function(reasonCode, description) {
		// if the status is not suspended or undefined (disconnected)
		// then run the disconnect function to properly disconnect
		if(this._status !== this.statuses.SUSPENDED &&
			this._status !== undefined){
			this.disconnect();
		}
	}.bind(this));

	// kick off the handshake
	this.sendMessage({handshake: TsProtocol.messages.HS_GET_CLIENT_INFO}, {toId: this.getId()}, this._handshakeHandler.bind(this));
}

// make event pub/sub easy peasy
util.inherits(Client, events.EventEmitter);


///////////////////////////////////////
// MESSAGE ROUTING, SENDING, PROCESSING
// 
Client.prototype._onMessage = function(msg){
	var message;

	try {
		message = JSON.parse(msg.utf8Data);
	}
	catch(e){
		logger.error("Unable to parse message. Dropping message.");
		return;
	}

	// TODO - reevalulate this and msg.utf8Data to make more sense
	if (msg.type != 'utf8'){
		// TODO - change to correct error message
		logger.error(TsProtocol.errors.INVALID_MESSAGE);
		this.sendError(TsProtocol.errors.INVALID_MESSAGE, {originalMessage: message});
		return;
	}

	// all messages must specify a toId
	if (!message.toId) {
		logger.error(TsProtocol.errors.RECIPIENT_ID_NOT_SPECIFIED);
		this.sendError(TsProtocol.errors.RECIPIENT_ID_NOT_SPECIFIED, {originalMessage: message});
		return;
	}

	// IMPORTANT: server is responsible for appending WHO this message is from
	message.fromId = this.getId();
	this.emit("message", message);

	logger.debug("Received message", message);

	// this message is intended for the server (probably part of a handshake)
	if (message.toId === TsProtocol.serverId) {
		this._processMessage(message);

	// this message is intended for another recipient and should be routed
	} else {
		logger.debug("Routing message");
		this.emit("routeMessage", this, message);
	}
};

/**
 * if the message is addressed to the server and is a response to a previous message,
 * invoke the original message's responseCallback.
 * @param  {Object}  message  the message to process
 */
Client.prototype._processMessage = function(message) {
	var originalMessage;
	logger.debug("Message is meant for server. Processing...");

	// the last argument of replyWith is a responseCallback
	// the last argument of responseCallback is a replyWith
	var replyWith = function(responseMessage, responseCallback) {
		this.sendMessage(responseMessage, {responseMessage: message}, responseCallback);
	}.bind(this);

	// if this is a response, call the response callback
	if (message.responseToMessageId) {
		originalMessage = this.messageStash.pull(message.responseToMessageId);
		if (originalMessage) {
			logger.debug("Calling callback stored for previous message");
			originalMessage.responseCallback(null, message.data, replyWith);

		} else {
			logger.debug("Ignoring response received for unknown or timed out message...");
		}

	// there are a few hardcoded server commands for now.
	} else {
		if(message.data && message.data.cmd){

			switch(message.data.cmd){
				case TsProtocol.commands.GET_CLIENTS_WITH_CAPABILITY:
					logger.debug("Getting clients with capability");

					this.emit("getClientsWithCapability", this, message.data.params, replyWith);
					break;

				case TsProtocol.commands.SUSPEND:
					logger.debug("Suspending client");

					this.disconnect();
					break;

				default:
					logger.debug("error", "Ignoring unknown server command", message.data.cmd);
					break;
			}
		}
	}
};

/**
 * Contains available statuses
 */
Client.prototype.statuses = {
	SUSPENDED: "suspended",
	CONNECTED: "connected",
	REJECTED:  "rejected"
}

/**
 * sends a message via the websocket
 * @param  data  the message. the contents can be whatever you want. except for live animals. thats illegal.
 * @param  {Object}  opts
 * @param  {Object}  opts.responseMessage  a previous message. used if this is a response to a previous message.
 * @param  {String}  opts.toId  if the recipient cannot be inferred from responseMessage or from the connection, then this is required.
 * @param  {Function}  responseCallback  after a message recieves a response, this callback is available to respond to the response. it takes 3 arguments: responseMessage - the message that was sent in response, responder - the callback to respond to the response, and error - if there was an error?
 */
Client.prototype.sendMessage = function(data, opts, responseCallback) {
	opts = opts || {};

	var message,
		toId = opts.responseMessage && opts.responseMessage.fromId || opts.toId || this.getId();

	if(!toId){
		logger.error(TsProtocol.errors.RECIPIENT_ID_NOT_SPECIFIED);
		return;
	}

	message = {
		fromId : TsProtocol.serverId,
		toId : toId,
		id : utils.uuid(),
		data : data
	};

	if(opts.responseMessage){
		// this is a response, so include the responseMessage id
		message.responseToMessageId = opts.responseMessage.id;
	}
	if(responseCallback) {
		// if there is a responseCallback, stash this message so the responseCallback can be
		// performed if/when the message receives a response
		this.messageStash.stash({ automationSocket : this, message: message, responseCallback : responseCallback });
	}

	logger.debug("Sending message "+ (opts.responseMessage ? "reply" : ""), message);

	this._connection.sendUTF(JSON.stringify(message));
};

Client.prototype.sendError = function(data, opts) {
	var err = this.formatError(data);
	this.sendMessage(err, opts);
};

Client.prototype.disconnect = function(){
	var suspendTimeout = this._messageTimeout - 1000;
	logger.debug("Client disconnected. Waiting " + suspendTimeout + "ms before removal");
	this._setStatus(this.statuses.SUSPENDED);

	// in case _suspendTimer was already set
	if(this._suspendTimer){
		clearInterval(this._suspendTimer);
		this._suspendTimer = undefined;
	}

	this._suspendTimer = setTimeout(function(){
		logger.debug("Requesting removal from Clients list");
		this.emit("remove", this);
	}.bind(this), suspendTimeout);

	// close websocket here instead of having close
	// event call this event. fixes #300
	if(this._connection){
		this._connection.close();
		this._connection = null;
	}
};

Client.prototype.formatError = function(errorData) {
	return { error: errorData };
};

Client.prototype._failHandshake = function(error, replyWith) {
	logger.error(error);

	var err = this.formatError(error);
	replyWith(err);

	this.disconnect();
};

///////////////////////////////////////
// EVENT HANDLERS
// 
Client.prototype._handshakeHandler = function(error, responseMessage, replyWith){
	if(error){
		logger.error(error);
		return;
	}

	/* a valid client info object looks like this: {
	 "version": "2",
	 "platformInfo": {
	 "platformKey": "web",
	 "name": "Chrome",
	 "platform": "Win32",
	 "system": "Windows",
	 "systemVersion": "",
	 "browser": {
	 "name": "Chrome",
	 "version": "32.0.1700.107"
	 }
	 },
	 "capabilities": [
	 "automation_execution_agent"
	 ],
	 "identity": {
	 "sharedKey": "5e2e79fa-a3b3-9b65-a9ee-dafa1d83fc68"
	 }
	 }*/

	// validate message structure
	if (!responseMessage.version || !responseMessage.platformInfo || !responseMessage.capabilities || !responseMessage.identity) {
		this._failHandshake(TsProtocol.errors.HANDSHAKE_FAILED, replyWith);
		return;
	}

	// validate version match
	if (responseMessage.version !== TsProtocol.version) {
		// if this is an attempted resume
		if(responseMessage.identity.resumeId){
			this.emit("failedHandshake", responseMessage.identity.sharedKey, responseMessage.identity.resumeId, TsProtocol.errors.VERSION_MISMATCH);
		}

		this._failHandshake(TsProtocol.errors.VERSION_MISMATCH, replyWith);
		return;
	}

	// complete handshake
	this._platformInfo = responseMessage.platformInfo;
	this._capabilities = responseMessage.capabilities;
	this._identity = responseMessage.identity;

	if(this._identity.resumeId){
		logger.debug("Attempting to resume previous session...");
		this.emit("resume", this, replyWith);
	}

	replyWith({
		handshake: TsProtocol.messages.HS_ACCEPTED,
		id: this.getId()
	});

	//handshake complete
	this._handshakeComplete();
};

Client.prototype._handshakeComplete = function() {
	// bind events
	// TODO - make these bindings more visible, further up
	this.on("connected", this._onConnect);
	this.emit("connected");

	logger.debug("Requesting registration of client");
	this.emit("register", this);
};

Client.prototype._onConnect = function(){
	logger.debug("Client connected");

	this._setStatus(this.statuses.CONNECTED);
};

 module.exports = Client;