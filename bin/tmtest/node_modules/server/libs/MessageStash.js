/**
 * MessageStash
 * caches messages for later retrieval. messages are retrieved
 * in order to execute a response callback if that message was
 * responded to. also checks if messages have timed out, and
 * removes them if they have.
 */

var DEFAULT_MESSAGE_TIMEOUT = 10000,
	TsProtocol = require('./TsAutomationProtocol.js');

/**
 * MessageStash constructor
 * @param {messageTimeout} timeout - the message timeout
 */
function MessageStash(timeout) {
	this._activeMsgsById = {};
	this._timeout = timeout || DEFAULT_MESSAGE_TIMEOUT;
	this._pollFrequency = 100;
	this._expirationTimerStarted = false;
	this._startTimer();
}

MessageStash.prototype = {
	constructor: MessageStash,

	/**
	 * stash a message and timestamp it for removal when timestamp expires
	 * @param  {Object} msg message to stash
	 * @param  {Number} [timeout] amount of time to wait before removing message
	 * @param  {Number} [timestamp] a date in ms at which to timeout the message
	 */
	stash: function(msg, timeout, timestamp){
		if(!(msg && msg.message && msg.message.id)) {
			throw "Invalid message format";
		}
		if(timeout && typeof(timeout) !== "number"){
			throw "Timeout must be a number";
		}
		if(timestamp && typeof(timestamp) !== "number"){
			throw "Timestamp must be a number";
		}

		// if a timestamp is supplied, use that (time + timeout). otherwise
		// use the default timeout, or the user supplied timeout
		msg.timestamp = timestamp || new Date().getTime() + (timeout || this._timeout);
		this._activeMsgsById[msg.message.id] = msg;
	},

	pull: function(id, includeTimestamp){
		if (this._activeMsgsById[id]) {
			var msg = this._activeMsgsById[id];

			// when auto-resending messages, the timestamp
			// is useful to know
			if(!includeTimestamp){
				delete msg.timestamp;
			}

			delete this._activeMsgsById[id];
			return msg;
		}
	},

	_startTimer: function(){
		this._expirationTimerStarted = true;
		setInterval(function(){
			var msg,
				currTime = new Date().getTime();

			for(var i in this._activeMsgsById){
				msg = this._activeMsgsById[i];

				if (currTime > msg.timestamp) {

					this.pull(msg.message.id);
					if(msg.responseCallback && typeof(msg.responseCallback) === "function") {
						msg.responseCallback(TsProtocol.errors.TIMEOUT);
					}
				}
			}
		}.bind(this), this._pollFrequency);
	}
};

module.exports = MessageStash;
